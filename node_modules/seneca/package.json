{
  "name": "seneca",
  "description": "A Micro-Services Framework for Node.js",
  "keywords": [
    "micro",
    "service",
    "framework",
    "minimum",
    "viable",
    "product",
    "toolkit",
    "startup"
  ],
  "version": "0.5.17",
  "license": "MIT",
  "homepage": "http://senecajs.org",
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com/"
  },
  "contributors": [
    {
      "name": "Richard Rodger",
      "url": "http://richardrodger.com/"
    },
    {
      "name": "Peter Elger"
    },
    {
      "name": "Marian Radulescu"
    },
    {
      "name": "Alexandru Mircea"
    },
    {
      "name": "Cristian Ianto"
    },
    {
      "name": "Dominic Tarr"
    }
  ],
  "dependencies": {
    "gex": "~0.1.3",
    "parambulator": "~0.1.6",
    "async": "~0.7.0",
    "patrun": "~0.1.5",
    "jsonic": "~0.1.1",
    "seneca-web": "~0.1.3",
    "seneca-transport": "~0.1.2",
    "norma": "~0.2.3",
    "underscore": "~1.5.2",
    "rolling-stats": "~0.1.0",
    "optimist": "~0.6.1",
    "nid": "~0.3.2"
  },
  "main": "lib/seneca",
  "files": [
    "LICENSE.txt",
    "README.md",
    "CHANGES.md",
    "lib",
    "plugin"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/rjrodger/seneca.git"
  },
  "scripts": {
    "test": "mocha test/*.test.js test/plugin/*.test.js",
    "build": "./build.sh"
  },
  "devDependencies": {
    "mocha": "~1.13.0",
    "jshint": "~2.1.11",
    "chai": "~1.9.1",
    "docco": "~0.6.2",
    "fixture-stdout": "~0.2.1"
  },
  "readme": "# seneca - Node.js module\n\n## A Node.js toolkit for startups building Minimum Viable Products\n\nSeneca is a toolkit for organizing the business logic of your app. You\ncan break down your app into \"stuff that happens\", rather than\nfocusing on data models or managing dependencies.\n\nFor a gentle introduction to this module, see the [senecajs.org](http://senecajs.org) site.\n\n\nIf you're using this module, feel free to contact me on twitter if you\nhave any questions! :) [@rjrodger](http://twitter.com/rjrodger)\n\nCurrent Version: 0.5.17\n\nTested on: Node 0.10.24, and 0.11 on Travis\n\n[![Build Status](https://travis-ci.org/rjrodger/seneca.png?branch=master)](https://travis-ci.org/rjrodger/seneca)\n\n\nUse this module to define commands that work by taking in some JSON,\nand, optionally, returning some JSON. The command to run is selected\nby pattern-matching on the the input JSON.  There are built-in and\noptional sets of commands that help you build Minimum Viable Products:\ndata storage, user management, distributed logic, caching, logging,\netc.  And you can define your own product by breaking it into a set of\ncommands - \"stuff that happens\".\n\nThat's pretty much it.\n\n\n_Why do this?_\n\nIt doesn't matter,\n\n   * who provides the functionality,\n   * where it lives (on the network),\n   * what it depends on,\n   * it's easy to define blocks of functionality (plugins!).\n\nSo long as _some_ command can handle a given JSON document, you're good.\n\nHere's an example:\n\n```javascript\nvar seneca = require('seneca')()\n\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  var rate  = 0.23\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\nseneca.act( {cmd:'salestax', net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nIn this code, whenever seneca sees the pattern\n<code>{cmd:'salestax'}</code>, it executes the function associated\nwith this pattern, which calculates sales tax. Yah!\n\nThe _seneca.add_ method adds a new pattern, and the function to execute whenever that pattern occurs.\n\nThe _seneca.act_ method accepts an object, and runs the command, if any, that matches.\n\nWhere does the sales tax rate come from? Let's try it again:\n\n```javascript\nseneca.add( {cmd:'config'}, function(args,callback){\n  var config = {\n    rate: 0.23\n  }\n  var value = config[args.prop]\n  callback(null,{value:value})\n})\n\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  seneca.act( {cmd:'config', prop:'rate'}, function(err,result){\n    var rate  = parseFloat(result.value)\n    var total = args.net * (1+rate)\n    callback(null,{total:total})\n  })\n})\n\nseneca.act( {cmd:'salestax', net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nThe _config_ command provides you with your configuration. This is\ncool because it doesn't matter _where_ it gets the configuration from\n- hard-coded, file system, database, network service, whatever. Did\nyou have to define an abstraction API to make this work? Nope.\n\nThere's a little but too much verbosity here, don't you think? Let's fix that:\n\n\n```javascript\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nBy _pinning_ a pattern, you get a little API of matching function calls.\nThe _shop_ object gets a set of methods that match the pattern: _shop.salestax_ and _shop.config_.\n\n\n_Programmer Anarchy_\n\nThe way to build Node.js systems, is to build lots of little\nprocesses. Here's a great talk explaining why you should do this:\n[Programmer Anarchy](http://vimeo.com/43690647).\n\nSeneca makes this really easy. Let's put configuration out on the\nnetwork into its own process:\n\n```javascript\nseneca.add( {cmd:'config'}, function(args,callback){\n  var config = {\n    rate: 0.23\n  }\n  var value = config[args.prop]\n  callback(null,{value:value})\n})\n\nseneca.listen()\n```\n\nThe _listen_ method starts a web server that listens for JSON\nmessages. When these arrive, they are submitted to the local Seneca\ninstance, and executed as actions in the normal way.  The result is\nthen returned to the client as the response to the HTTP\nrequest. Seneca can also listen for actions via a message bus.\n\nYour implementation of the configuration code _stays the same_.\n\nThe client code looks like this:\n\n\n```javascript\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  seneca.act( {cmd:'config', prop:'rate'}, function(err,result){\n    var rate  = parseFloat(result.value)\n    var total = args.net * (1+rate)\n    callback(null,{total:total})\n  })\n})\n\nseneca.client()\n\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100}, function(err,result){\n  console.log( result.total )\n})\n```\n\nOn the client-side, calling _seneca.client()_ means that Seneca will\nsend any actions it cannot match locally out over the network. In this\ncase, the configuration server will match the _cmd:config_ pattern and\nreturn the configuratin data.\n\nAgain, notice that your sales tax code _does not change_. It does not\nneed to know where the configuration comes from, who provides it, or\nhow.\n\nYou can do this with every command.\n\n\n_Keeping the Business Happy_\n\nThe thing about business requirements is that have no respect for\ncommon sense, logic or orderly structure. The real world is\nmessy. \n\nIn our example, let's say some countries have single sales tax rate,\nand others have a variable rate, which depends either on locality, or product category.\n\nHere's the code. We'll rip out the configuration code for this example.\n\n```javascript\n// fixed rate\nseneca.add( {cmd:'salestax'}, function(args,callback){\n  var rate  = 0.23\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\n// local rates\nseneca.add( {cmd:'salestax',country:'US'}, function(args,callback){\n  var state = {\n    'NY': 0.04,\n    'CA': 0.0625\n    // ...\n  }\n  var rate = state[args.state]\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\n// categories\nseneca.add( {cmd:'salestax',country:'IE'}, function(args,callback){\n  var category = {\n    'top': 0.23,\n    'reduced': 0.135\n    // ...\n  }\n  var rate = category[args.category]\n  var total = args.net * (1+rate)\n  callback(null,{total:total})\n})\n\n\nvar shop = seneca.pin({cmd:'*'})\n\nshop.salestax({net:100,country:'DE'}, function(err,result){\n  console.log( 'DE: '+result.total )\n})\n\nshop.salestax({net:100,country:'US',state:'NY'}, function(err,result){\n  console.log( 'US,NY: '+result.total )\n})\n\nshop.salestax({net:100,country:'IE',category:'reduced'}, function(err,result){\n  console.log( 'IE: '+result.total )\n})\n\n```\n\nIn this case, you provide different implementations for different\npatterns. This lets you isolate complexity into well-defined\nplaces. It also means you can deal with special cases very easily.\n\n\n\n_Source_\n\nThe [Seneca source code](http://senecajs.org/doc/seneca.html) is annotated.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/rjrodger/seneca/issues"
  },
  "_id": "seneca@0.5.17",
  "_shasum": "44d8eb8011f8dfe5925086a9d5a21636b1579363",
  "_from": "seneca@",
  "_resolved": "https://registry.npmjs.org/seneca/-/seneca-0.5.17.tgz"
}
