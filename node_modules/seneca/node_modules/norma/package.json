{
  "name": "norma",
  "version": "0.2.6",
  "description": "A function argument organizer",
  "main": "norma.js",
  "scripts": {
    "test": "mocha test/*.test.js",
    "build": "pegjs norma-parser.pegjs",
    "jshint": "jshint norma.js",
    "docco": "docco norma.js -o doc",
    "gh-pages-doc": "cp -r doc/* ../gh-pages/norma/doc"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/rjrodger/norma.git"
  },
  "keywords": [
    "norma"
  ],
  "author": {
    "name": "Richard Rodger",
    "url": "http://richardrodger.com"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/rjrodger/norma/issues"
  },
  "homepage": "https://github.com/rjrodger/norma",
  "devDependencies": {
    "pegjs": "~0.8.0",
    "mocha": "~1.17.1",
    "docco": "~0.6.3",
    "jshint": "~2.5.0"
  },
  "dependencies": {
    "underscore": "~1.6.0",
    "eraro": "~0.1.2"
  },
  "readme": "norma\n=====\n\n### A function argument organizer\n<small>[docco](http://rjrodger.github.io/norma/doc/norma.html)<small>\n\nSometimes you want your functions to accept optional arguments. It makes your API nicer.\n\nFor example, the basic function signature is:\n\n```JavaScript\nmyAPI.doStuff( 'the-stuff', function( err, result ){ ... } )\n```\n\nBut you also want to support options:\n\n```JavaScript\nmyAPI.doStuff( 'the-stuff', \n               { option1:'foo', option2:'bar'}, \n               function( err, result ){ ... } )\n```\n\nThe callback should be the last argument. That's the style. So you have to write a bit of logic to test if the second argument\nis an object or a function and act appropriately. Ths is cruft code getting in the way of real work.\n\n```JavaScript\nmyAPI.doStuff = function(){\n  var stuff    = arguments[0]\n  var options  = 'function' == typeof(arguments[1]) ? {} : arguments[1]\n  var callback = 'function' == typeof(arguments[2]) ? arguments[2] : arguments[1]\n  ...\n}\n```\n\n\nWith this module, you specify what you want using a simple expression language:\n\n```JavaScript\nmyAPI.doStuff = function(){\n  var args = norma('so?f',arguments)\n\n  var stuff    = args[0]\n  var options  = args[1] || {}\n  var callback = args[2]\n}\n```\n\nNow your arguments always come back in a well-defined array, and always at the same index.\n\nThe expression 'so?f' means match: a string, an optional object, and a function\n\nYou can also assign names:\n\n\n```JavaScript\nmyAPI.doStuff = function(){\n  var args = norma('stuff:s options:o? callback:f',arguments)\n  // args == {stuff:..., options:..., callback:...}\n  args.options = args.options || {}\n}\n```\n\nAnd of course, if your function is called with arguments that do not match the expression, then an error is thrown.\n\n\n\n\n### Support\n\nIf you're using this module, feel free to contact me on twitter if you have any questions! :) [@rjrodger](http://twitter.com/rjrodger)\n\nCurrent Version: 0.2.6\n\nTested on: node 0.10.26\n\n[![Build Status](https://travis-ci.org/rjrodger/norma.png?branch=master)](https://travis-ci.org/rjrodger/norma)\n\n\n\n### Quick example\n\n```JavaScript\nvar norma = require('norma')\n\nfunction foo() {\n  var args = norma('sf', arguments)\n\n  var content = args[0]  // s => string, required\n  var cb      = args[1]  // f => function, required\n\n  cb(null,content+'!')\n}\n\nfoo('bar',function(err,out){\n  console.log(out)\n})\n```\n\n\n## Install\n\n```sh\nnpm install norma\n```\n\n\n# Function Signature Expression\n\nThe expression you use to define the function argument types that you\nexpect is a string containing individual characters that stand for\nJavaScript types. Each type is a single character. These are:\n\n   * s - string    \n   * i - integer   \n   * n - number    \n   * b - boolean   \n   * f - function  \n   * a - array     \n   * o - object    \n   * r - regexp    \n   * d - date      \n   * g - arguments \n   * e - error     \n   * N - null      \n   * U - undefined \n   * A - NaN       \n   * Y - Infinity  \n\nYou list the types you expect, in the order you expect. The _norma_\nmodule will return an array with each position corresponding to the position of each type letter.\n\nThis works like so:\n\n   * \"s\"   => [string]                   => [ \"Foo\" ]\n   * \"si\"  => [string, integer]          => [ \"Foo\", 123 ]\n   * \"sbi\" => [string, boolean, integer] => [ \"Foo\", true, 123 ]\n\n\nThe syntax of the expression is similar to a regular expression (but it's not one!). You can use these special characters:\n\n   * . - match any type\n   * ? - preceding type is optional (also matches null, undefined, and NaN)\n   * * - preceding type can occur any number of times (including zero)    \n   * + - preceding type can occur any number of times (but must occur at least once)    \n   * | - set of alternate types that are valid in this argument position\n\nNow you can do this:\n\n   * \"so?f\" => [ string, optional object, function ] => [ \"a\", function(){...} ]; [ \"a\", {b:1}, function(){...} ]\n   * \"s?n\"  => [ optional string, number ] => [ \"a\", 1 ]; [ 1 ]\n   * \"si*\"  => [ string, zero or more integers... ] => [ \"a\" ]; [ \"a\", 1 ]; [ a, 1, 2 ]; [ a, 1, 2, 3 ]\n   * \"si+\"  => [ string, one or more integers... ] => [ \"a\", 1 ]; [ a, 1, 2 ]; [ a, 1, 2, 3 ]\n   * \"s.*\"  => [ string, anything... ] => [ \"a\", true ]; [ a, {}, [] ]; [ a, 3, {}, true, /hola/ ]\n   * \"s|if\" => [ string or integer, function ] => [ \"a\", function(){...} ]; [ 1, function(){...} ];\n\nYou can use whitespace and commas to make things more readable:\n\n  * \"so?f\" === \"s o? f\" === \"s, o?, f\" \n\nIf no match is found for a given position, _undefined_ is used as the placeholder:\n\n  * \"si*\" on [ \"a\" ] gives [ \"a\", undefined ]\n  * \"s.*b\" on [ \"a\", true ] gives [ \"a\", undefined, true ]\n\nAlternates can also be optional, so this works too:\n\n   * \"s|i? b\" => [ optional string or integer, boolean ] => [ true ]; [ \"a\", true ]; [ 1, true ];\n\nNote that you'll get an _undefined_ as the placeholder, as usual:\n\n   * \"s|i? b\" on [ true ]; [ \"a\", true ]; [ 1, true ]; gives [ undefined, true ]; [ \"a\", true ]; [ 1, true ]; \n\nYou can also give arguments names. These are set as properties on the returned array, as well being assigned an index:\n\n  * \"foo:s\" => [ \"val\", foo:\"val\" ]  // in util.inspect output format\n\nIf you really want an object, use the form:\n\n  * \"{foo:s}\" => { foo:\"val\" }\n\nIf you use the * modifier, and a name, then you'll get back an array listing all the matches (zero or more).\n\n  * \"{foo:s*}\" => { foo: [\"v1\",\"v2\",...] }\n\nAnd that's it!\n\n\n## Compiling patterns\n\nYou can compile a pattern ahead of time:\n\n```JavaScript\nvar norma = require('norma')\n\nvar needstring = norma.compile('s')\n\nfunction foo() {\n  var args = needstring( arguments )\n  console.log( 'string:'+args[0] ) \n}\n```\n\n\n\n## How it Works\n\nThe parser uses [PEG.js](http://pegjs.majda.cz/) to understand the\nsignature expression, and then it builds an internal regular\nexpression to match the function argument types.\n\n\nThe source code is [annotated](http://rjrodger.github.io/norma/doc/norma.html).\n\n\n\n# Development\n\nEdit _norma-parser.pegjs_ to modify the grammar. Rebuild with _npm run build_.\n\n\nTest with:\n\n```bash\nnpm test\n```\n\n",
  "readmeFilename": "README.md",
  "_id": "norma@0.2.6",
  "_from": "norma@~0.2.3"
}
